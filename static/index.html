<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modela Ai IOT</title>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <link rel="stylesheet" href="static/styles.css?v=5" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Prompt&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
</head>
<body>
  <div class="main-layout">
    <!-- Header Section -->
    <div class="header">
      <h1><i class="fa-solid fa-camera"></i> Modela AI Camera Counting</h1>
      <div class="datetime">
        <span class="live-indicator"></span>
        <i class="fa-regular fa-clock"></i>
        ‡∏ß‡∏±‡∏ô <span id="day"></span>
      </div>
    </div>
    <!-- Video Section (Main Content) -->
    <div class="video-container">
      <div class="testfullscreen">
        <video id="video" class="showvideostream" autoplay playsinline muted></video>
        <div id="no-camera-message" class="no-camera-message">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏•‡πâ‡∏≠‡∏á<span class="loading-dots"></span></div>
        <button class="fullscreen-btn" id="fullscreenButton" onclick="toggleFullscreen()"><i class="fa-solid fa-maximize"></i> ‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠</button>
        <button class="exit-fullscreen-btn" id="exitFullscreenButton" onclick="toggleFullscreen()"><i class="fa-solid fa-xmark"></i> ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏ï‡πá‡∏°‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠</button>
      </div>
    </div>

    <!-- Controls Section -->
    <div class="controls-container">
      <div class="select-group">
        <label for="cam">üé• ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏•‡πâ‡∏≠‡∏á</label>
        <select id="cam">
          <option value="0" selected>‡∏Å‡∏•‡πâ‡∏≠‡∏á 1</option>
          <option value="1">‡∏Å‡∏•‡πâ‡∏≠‡∏á 2</option>
        </select>
      </div>

     <div class="draw-polygon">
      <button class="popup-panel-btn" id="drawPolygonButton">
        <i class="fa-solid fa-draw-polygon"></i> ‡∏ß‡∏≤‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏±‡∏ö
      </button>

      <button class="clear-polygon-btn" id="clearPolygonButton"
        onclick="if(confirm('‚ö†Ô∏è ‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡πâ‡∏≤‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?')) { 
          fetch('/clear_polygons', { method: 'POST' })
          .then(() => { alert('‚úÖ ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏±‡∏ö‡∏ñ‡∏π‡∏Å‡∏•‡πâ‡∏≤‡∏á‡πÅ‡∏•‡πâ‡∏ß'); })
          .catch(err => { 
            console.error('‚ùå ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡πâ‡∏≤‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏±‡∏ö:', err); 
            alert('‚ùå ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏•‡πâ‡∏≤‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏±‡∏ö'); 
          }); 
        }">
        <i class="fa-solid fa-trash"></i> ‡∏•‡πâ‡∏≤‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏±‡∏ö
      </button>
    </div>
  </div>

  <!-- Pop-up moved outside main-layout -->
  <div id="capturePopup" class="popup-overlay">
    <div class="popup-content">
      <h2>‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏∏‡∏î‡∏ß‡∏≤‡∏î‡∏Å‡∏£‡∏≠‡∏ö</h2>
      <span class="close-btn" id="closePopup">
        <i class="fa-solid fa-xmark"></i>
      </span>
     <div class="popup-body">
        <div class="canvas-with-buttons">
          <div class="image-canvas-container fixed-size">
            <img id="capturedImage" alt="Captured snapshot" width="640" height="360" />
            <canvas id="drawCanvas" width="640" height="360"></canvas>
          </div>
          <div class="side-buttons">
              <button id="ResetPoint" class="btn-base btn-neutral">
                <i class="fa-solid fa-trash"></i> Reset
              </button>
              <button id="UndoPoint" class="btn-base btn-warning">
                <i class="fa-solid fa-undo"></i> Undo
              </button>
              <button id="SavePolygon" class="btn-base btn-success">
                <i class="fa-solid fa-floppy-disk"></i> Draw
              </button>
              <div id="DeleteButtons"></div>
              <button id="SendPolygonData" class="btn-base btn-info">
                <i class="fa-solid fa-paper-plane"></i> Finish
              </button>
            <div class="polygoninfo">
              <div class="polygoncount">0</div>
              <div class="pointcount">0</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let current_stream = {
      selected_cam_id: null,  // Changed from selected_cam index to camera ID
      cameras: []
    };

    let pc;
    let isRestarting = false;
    let highlightedPolygon = null; 
    let historyStack = [];

    // Polygon drawing variables
    let points = [];
    const canvas = document.getElementById("drawCanvas");
    const ctx = canvas.getContext("2d");


    // ‚úÖ FIXED: Get camera by array index (not ID)
    function getCurrentCamera() {
      return current_stream.cameras.find(c => c.id === current_stream.selected_cam_id);
    }

    // ‚úÖ FIXED: Find camera by ID when needed
    function findCameraById(id) {
      return current_stream.cameras.find(c => c.id === id);
    }

    // ---- WebRTC setup ----
    const config = {
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
      sdpSemantics: "unified-plan"
    };

    async function restartStream() {
      if (isRestarting) return;
      isRestarting = true;

      if (pc) {
        try {
          pc.getSenders().forEach(sender => pc.removeTrack(sender));
          await pc.close();
        } catch (err) {
          console.warn("‚ö†Ô∏è Error closing previous pc:", err);
        }
        pc = null;
      }

      pc = new RTCPeerConnection(config);
      pc.ontrack = (event) => { document.getElementById("video").srcObject = event.streams[0]; };

      try {
        const canvas = document.createElement("canvas");
        canvas.width = 640; canvas.height = 360;
        const stream = canvas.captureStream();
        const dummyTrack = stream.getVideoTracks()[0];
        pc.addTrack(dummyTrack);

        const offer = await pc.createOffer({ offerToReceiveVideo: true });
        await pc.setLocalDescription(offer);

        const startTime = performance.now();
        const res = await fetch("/offer", {
          method: "POST",
          body: JSON.stringify({ sdp: pc.localDescription.sdp, type: pc.localDescription.type }),
          headers: { "Content-Type": "application/json" }
        });
        console.log(`Signaling latency: ${performance.now() - startTime} ms`);

        const answer = await res.json();
        await pc.setRemoteDescription(answer);
      } catch (err) {
        console.error("üö® WebRTC restart error:", err);
      }
      isRestarting = false;
    }

    function getCurrentCamera() {
      return current_stream.cameras.find(c => c.id === current_stream.selected_cam_id);
    }

    function pushHistory() {
      const cam = getCurrentCamera();
      if (!cam) return;
      const snapshot = JSON.parse(JSON.stringify(cam));
      historyStack.push({ camIndex: current_stream.selected_cam, snapshot, points: [...points] });
    }

    async function startStream() {
      pc = new RTCPeerConnection(config);
      pc.ontrack = (event) => {
        console.log("üé• Got WebRTC stream");
        document.getElementById("video").srcObject = event.streams[0];
      };

      try {
        const canvas = document.createElement("canvas");
        canvas.width = 640; canvas.height = 360;
        const stream = canvas.captureStream();
        const dummyTrack = stream.getVideoTracks()[0];
        pc.addTrack(dummyTrack);

        const offer = await pc.createOffer({ offerToReceiveVideo: true });
        await pc.setLocalDescription(offer);

        const startTime = performance.now();
        const res = await fetch("/offer", {
          method: "POST",
          body: JSON.stringify({ sdp: pc.localDescription.sdp, type: pc.localDescription.type }),
          headers: { "Content-Type": "application/json" }
        });
        console.log(`Signaling latency: ${performance.now() - startTime} ms`);

        const answer = await res.json();
        await pc.setRemoteDescription(answer);
      } catch (err) {
        console.error("üö® WebRTC connection error:", err);
      }
    }

    // ‚úÖ SIMPLIFIED: Just switch video stream directly
    async function sendSelection() {
      const selectedCameraId = current_stream.selected_cam_id;

      console.log(`Switching to camera ID: ${selectedCameraId}`);

      try {
        const res = await fetch("/set_frame", {
          method: "POST",
          body: JSON.stringify({ camera_id: selectedCameraId }),  // Send ID, not index
          headers: { "Content-Type": "application/json" }
        });
        
        if (res.ok) {
          const responseData = await res.json();
          console.log("Camera switched:", responseData);
          await restartStream();
        } else {
          throw new Error(`Failed to switch camera: ${res.status}`);
        }
        
      } catch (err) {
        console.error("Camera switch failed:", err);
      }
    }

    async function syncCameraData() {
      try {
        const res = await fetch(`/polygons.json?t=${Date.now()}`, { cache: "no-store" });
        if (!res.ok) throw new Error("Failed to fetch polygons.json");
        const data = await res.json();

        current_stream.cameras = data.cameras || [];
        // Backend now returns selected_cam_id instead of selected_cam index
        current_stream.selected_cam_id = data.selected_cam_id || (data.cameras[0]?.id);

        updateCameraDropdown();
        
        console.log("Synced camera data:", {
          cameras: current_stream.cameras,
          selected_cam_id: current_stream.selected_cam_id
        });
        
        return true;
      } catch (err) {
        console.error("Failed to sync camera data:", err);
        return false;
      }
    }

    // ‚úÖ FIXED: Update camera dropdown with proper sync
    function updateCameraDropdown() {
      const camSelect = document.getElementById("cam");
      camSelect.innerHTML = "";
      
      current_stream.cameras.forEach((cam) => {
        const opt = document.createElement("option");
        opt.value = cam.id;  // Use camera ID directly, not index
        opt.textContent = `Camera ${cam.id}`;  // Show just the camera ID
        if (cam.id === current_stream.selected_cam_id) opt.selected = true;
        camSelect.appendChild(opt);
      });
    }

    // Modified draw polygon button handler
    document.getElementById("drawPolygonButton").addEventListener("click", async () => {
      console.log("Opening polygon drawing modal");

      // CRITICAL: Refresh camera data from backend before opening modal
      console.log("üîÑ Force refreshing camera data before opening polygon editor...");
      const syncSuccess = await syncCameraData();
      if (!syncSuccess) {
        alert("Failed to sync camera data. The camera list might be outdated. Please refresh the page and try again.");
        return;
      }

      // Now get the current camera - this should work correctly
      const currentCam = getCurrentCamera();
      console.log("Current camera after sync:", currentCam);
      console.log("All cameras after sync:", current_stream.cameras);
      
      // Verify we have a valid camera
      if (!currentCam) {
        alert("‚ùå No camera found for current selection. Please check camera configuration.");
        return;
      }

      console.log(`‚úÖ Drawing polygons for camera ID: ${currentCam.id}`);

      const capturePopup = document.getElementById("capturePopup");
      const capturedImage = document.getElementById("capturedImage");

      if (!capturePopup || !capturedImage) {
        alert("Error: Popup elements not found");
        return;
      }

      try {
        console.log("Fetching image from /capture.jpg");
        const res = await fetch(`/capture.jpg?fmt=jpg&w=640&h=360&_=${Date.now()}`, {
          method: "GET",
          cache: "no-store"
        });

        if (!res.ok) throw new Error(`Failed to capture image: ${res.status}`);

        const blob = await res.blob();
        const url = URL.createObjectURL(blob);

        if (capturedImage.src) {
          URL.revokeObjectURL(capturedImage.src);
          capturedImage.src = "";
        }

        capturedImage.src = url;
        capturePopup.style.display = "flex";

        const img = document.getElementById("capturedImage");
        img.onload = function() {
          canvas.width = 640;
          canvas.height = 360;
          points = [];
          drawAll();

          // Log which camera we're drawing polygons for
          const activeCam = getCurrentCamera();
          console.log(`‚úÖ Drawing polygons for camera index ${current_stream.selected_cam}, REAL ID: ${activeCam?.id}`);
        };
      } catch (err) {
        console.error("Capture failed:", err);
        alert("Failed to capture image: " + err.message);
      }
    });

    // Close modal and clean up
    document.getElementById("closePopup").addEventListener("click", () => {
      console.log("üî≤ Closing pop-up via close button");
      const capturePopup = document.getElementById("capturePopup");
      const capturedImage = document.getElementById("capturedImage");
      if (capturedImage.src) {
        URL.revokeObjectURL(capturedImage.src);
        capturedImage.src = "";
      }
      capturePopup.style.display = "none";
    });

    // Close if user clicks outside modal content
    document.getElementById("capturePopup").addEventListener("click", (e) => {
      if (e.target.id === "capturePopup") {
        console.log("üî≤ Closing pop-up via outside click");
        const capturePopup = document.getElementById("capturePopup");
        const capturedImage = document.getElementById("capturedImage");
        if (capturedImage.src) {
          URL.revokeObjectURL(capturedImage.src);
          capturedImage.src = "";
        }
        capturePopup.style.display = "none";
      }
    });

    // ================= Draw Polygon =================
    function drawAll() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const cam = getCurrentCamera();
      if (!cam) return;
      const polys = cam.polygons.filter(p => p.coord.length > 0);

      const colors = [
        { stroke: "lime",    fill: "rgba(0,255,0,0.25)" },
        { stroke: "cyan",    fill: "rgba(0,255,255,0.25)" },
        { stroke: "magenta", fill: "rgba(255,0,255,0.25)" },
        { stroke: "orange",  fill: "rgba(255,165,0,0.25)" }
      ];

      // Draw polygons
      polys.forEach((polyObj, idx) => {
        const poly = polyObj.coord;
        ctx.beginPath();
        ctx.moveTo(poly[0][0], poly[0][1]);
        for (let i = 1; i < poly.length; i++) ctx.lineTo(poly[i][0], poly[i][1]);
        ctx.closePath();

        const c = colors[idx % colors.length];

        if (highlightedPolygon === idx) {
          // highlight this polygon
          ctx.strokeStyle = c.stroke;
          ctx.lineWidth = 4;
          ctx.fillStyle = c.fill.replace("0.25", "0.5");
        } else if (highlightedPolygon !== null) {
          // dim non-highlighted polygons
          ctx.strokeStyle = "rgba(150,150,150,0.5)";
          ctx.lineWidth = 1;
          ctx.fillStyle = "rgba(200,200,200,0.1)";
        } else {
          // normal drawing
          ctx.strokeStyle = c.stroke;
          ctx.lineWidth = 2;
          ctx.fillStyle = c.fill;
        }

        ctx.stroke();
        ctx.fill();
      });

      // ‚úÖ Draw in-progress polygon INSIDE drawAll
      if (points.length > 0) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
        ctx.strokeStyle = "yellow";
        ctx.lineWidth = 2;
        ctx.stroke();

        points.forEach((p, i) => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
          ctx.fillStyle = "red";
          ctx.fill();
          ctx.fillText(i + 1, p.x + 8, p.y - 8);
        });
      }

      document.querySelector(".pointcount").textContent = points.length;
      document.querySelector(".polygoncount").textContent = polys.length;

      // ‚úÖ Build delete buttons dynamically
      const deleteContainer = document.getElementById("DeleteButtons");
      deleteContainer.innerHTML = "";
      deleteContainer.onmouseleave = () => {
        highlightedPolygon = null; 
        drawAll();
      };
      polys.forEach((_, idx) => {
        const btn = document.createElement("button");
        btn.innerHTML = `<i class="fa-solid fa-delete-left"></i> Delete Polygon ${idx + 1}`;

        btn.onmouseenter = () => {
          highlightedPolygon = idx;
          drawAll();
        };

        btn.onclick = () => {
          pushHistory();
          const cam = getCurrentCamera();
          if (!cam) return;

          cam.polygons[idx] = { coord: [], seen: 0, name: "" };
          highlightedPolygon = null;
          console.log(`üóëÔ∏è Deleted polygon ${idx + 1} on camera ${cam.id}`);
          drawAll();

          fetch("/save_polygons", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              camera_id: cam.id,
              polygons: cam.polygons.filter(p => p.coord.length > 0)
            })
          }).then(r => r.json()).then(resp => {
            console.log("‚úÖ Polygon deletion persisted:", resp);
          }).catch(err => {
            console.error("‚ùå Failed to persist deletion:", err);
          });
        };

        deleteContainer.appendChild(btn);
      });
    } 

    // Add point on click
    canvas.addEventListener("click", (e) => {
      pushHistory();
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      points.push({x, y});
      drawAll();
    });

    // ================ Button Handlers =================
    document.getElementById("ResetPoint").addEventListener("click", () => {
      pushHistory();
      const cam = getCurrentCamera();
      points = [];
      cam.polygons = [
        { coord: [], seen: 0, name: "" },
        { coord: [], seen: 0, name: "" }
      ];
      drawAll();
    });

    document.getElementById("UndoPoint").addEventListener("click", () => {
      points.pop();
      drawAll();
    });

    // Save polygon
    document.getElementById("SavePolygon").addEventListener("click", () => {
      if (points.length > 2) {
        pushHistory();
        const cam = getCurrentCamera();

        const existingCount = cam.polygons.filter(p => p.coord.length > 0).length;
        if (existingCount >= 2) {
          alert("‚ö†Ô∏è Only 2 polygons allowed per camera");
          points = [];
          drawAll();
          return;
        }

        const polyCoords = points.map(p => [p.x, p.y]);
        cam.polygons[existingCount] = {
          coord: polyCoords,
          seen: 0,
          name: "Polygon-" + (existingCount + 1)
        };

        console.log(`‚úÖ Polygon saved on Camera ${cam.id}:`, polyCoords);

        points = [];
        drawAll();
      } else {
        alert("Need at least 3 points to form a polygon!");
      }
    });

    // Finish: prepare data and send immediately
    document.getElementById("SendPolygonData").addEventListener("click", async () => {
      const cam = getCurrentCamera();

      if (!cam) {
        alert("‚ö†Ô∏è No camera selected!");
        console.error("‚ùå getCurrentCamera() returned null/undefined");
        return;
      }

      // Collect only polygons with coords
      const preparedData = {
        camera_id: cam.id,
        polygons: cam.polygons.filter(p => p.coord.length > 0)
      };

      // Debug logging
      console.log("üìä DEBUG - Current camera:", cam);
      console.log("üìä DEBUG - Prepared data:", preparedData);
      console.log("üìä DEBUG - Selected cam index:", current_stream.selected_cam);
      console.log("üìä DEBUG - All cameras:", current_stream.cameras);

      if (preparedData.polygons.length === 0) {
        alert("‚ö†Ô∏è No polygons to send!");
        return;
      }

      const confirmSend = confirm("‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á Polygon ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏£‡∏¥‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà?");
      if (!confirmSend) {
        console.log("üö´ User canceled sending polygons");
        return;
      }

      try {
        console.log("üì§ Sending polygon data:", JSON.stringify(preparedData, null, 2));
        
        const res = await fetch("/save_polygons", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(preparedData)
        });

        const responseText = await res.text();
        console.log("üì• Raw server response:", responseText);

        if (!res.ok) {
          throw new Error(`Server error ${res.status}: ${responseText}`);
        }

        let result;
        try {
          result = JSON.parse(responseText);
        } catch (parseErr) {
          console.error("Failed to parse response as JSON:", parseErr);
          throw new Error(`Invalid response format: ${responseText}`);
        }

        console.log("‚úÖ Parsed server response:", result);

        if (result.ok) {
          alert("Polygons sent successfully!");
        } else {
          throw new Error(result.error || "Unknown server error");
        }

      } catch (err) {
        console.error("‚ùå Failed to send polygons:", err);
        alert("Failed to send polygons: " + err.message);
      }
    });

    // Camera selection handler - ensure backend sync
    document.getElementById("cam").addEventListener("change", async (e) => {
      const newCameraId = parseInt(e.target.value, 10);  // This is now a camera ID
      const previousCameraId = current_stream.selected_cam_id;
      
      console.log(`Camera selection changed: ${previousCameraId} ‚Üí ${newCameraId}`);
      
      current_stream.selected_cam_id = newCameraId;  // Store camera ID
      
      try {
        const res = await fetch("/set_frame", {
          method: "POST",
          body: JSON.stringify({ camera_id: newCameraId }),  // Send camera ID
          headers: { "Content-Type": "application/json" }
        });
        
        if (!res.ok) {
          throw new Error(`Backend rejected camera selection: ${res.status}`);
        }
        
        const responseData = await res.json();
        console.log("Backend confirmed camera switch:", responseData);
        
        await restartStream();
        
      } catch (err) {
        console.error("Camera selection failed:", err);
        
        // Revert on failure
        current_stream.selected_cam_id = previousCameraId;
        e.target.value = previousCameraId;
        
        alert(`Failed to switch camera: ${err.message}`);
      }
    });

    // ---- UI utilities ----
    function getThaiDayName(dayIndex) {
      const dayNames = ["‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå", "‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå", "‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£", "‡∏û‡∏∏‡∏ò", "‡∏û‡∏§‡∏´‡∏±‡∏™‡∏ö‡∏î‡∏µ", "‡∏®‡∏∏‡∏Å‡∏£‡πå", "‡πÄ‡∏™‡∏≤‡∏£‡πå"];
      return dayNames[dayIndex];
    }

    function formatDate(date) {
      const dayName = getThaiDayName(date.getDay());
      const day = date.getDate();
      const month = date.getMonth() + 1;
      const year = date.getFullYear();
      const hours = String(date.getHours()).padStart(2, "0");
      const minutes = String(date.getMinutes()).padStart(2, "0");
      const seconds = String(date.getSeconds()).padStart(2, "0");
      return `${dayName} ${day}/${month}/${year} ${hours}:${minutes}:${seconds}`;
    }

    function updateDateTime() {
      const now = new Date();
      document.getElementById("day").textContent = formatDate(now);
    }

    function toggleFullscreen() {
      const videoContainer = document.querySelector(".testfullscreen");
      const video = document.getElementById("video");

      if (!document.fullscreenElement) {
        videoContainer.requestFullscreen().then(() => {
          video.classList.add("showvideostream_fullscreen");
          document.getElementById("fullscreenButton").style.display = "none";
          document.getElementById("exitFullscreenButton").style.display = "block";
        });
      } else {
        document.exitFullscreen().then(() => {
          video.classList.remove("showvideostream_fullscreen");
          document.getElementById("fullscreenButton").style.display = "block";
          document.getElementById("exitFullscreenButton").style.display = "none";
        });
      }
    }

    document.addEventListener("fullscreenchange", () => {
      if (!document.fullscreenElement) {
        document.getElementById("fullscreenButton").style.display = "inline-block";
        document.getElementById("exitFullscreenButton").style.display = "none";
      }
    });

    function undoAction() {
      if (historyStack.length === 0) {
        alert("‚ö†Ô∏è Nothing to undo!");
        return;
      }
      const last = historyStack.pop();
      if (last.camIndex !== current_stream.selected_cam) {
        console.warn("Undo skipped: different camera");
        return;
      }
      const cam = getCurrentCamera();
      if (cam) {
        Object.assign(cam, last.snapshot);
        points = last.points;
        drawAll();
      }
    }

    // ---- Init ----
    async function initialize() {
      await startStream();
      setInterval(updateDateTime, 1000);
      updateDateTime();

      await syncCameraData();

      // Send initial selection to ensure backend alignment
      await sendSelection();
    }

    // Start
    initialize();
  </script>
</body>
</html>